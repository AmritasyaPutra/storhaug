#!/bin/bash

# STORHAUG: High-Availability Storage Server
#
# Copyright (c) 2018 Red Hat Inc.
#   All Rights Reserved.
#
# License: GPLv2 or any later version.
#   See the file LICENSE or http://www.gnu.org/licenses/gpl-2.0.en.html#SEC1
#

. /etc/ctdb/ctdbd.conf

### Globals

HA_NUM_SERVERS=0
CTDB_NODES="/etc/ctdb/nodes"
CTDB_PUBLIC_ADDRESSES="/etc/ctdb/public_addresses"

# explicitly declare an array
declare -a HA_SERVERS

# path to private keys, used in ssh_do function
SECRET_PEM="/etc/sysconfig/storhaug.d/secret.pem"

# enumerates all configured addresses on all network interfaces. 
# loopback interface and IPv6 link-local addresses are omitted, example
# 172.16.64.241 192.168.122.1
MY_IPS=( $(hostname -I) )

### Utility functions

usage()
{
    echo "Configuration script for High-Availability Storage Server"
	echo "It is expected to be run only from one node as your lead node"
}

storlog()
{
    # uses syslog
    LEVEL=${1}; shift
    case ${LEVEL} in
        ERR|ERROR)
        echo "ERROR: $1" >&2
        logger --tag="storhaug" -p "daemon.err" "${1}"
        exit 1
        ;;
        WARN|WARNING)
        echo "WARNING: $1"
        logger --tag="storhaug" -p "daemon.warn" "${1}"
        ;;
        INFO)
        echo "$1"
        logger --tag="storhaug" -p "daemon.info" "${1}"
        ;;
        DEBUG)
        logger --tag="storhaug" -p "daemon.debug" "${1}"
        ;;
    esac
}

ssh_do()
{
    if [[ ${1} = ${MY_IPS[0]} ]]; then
        eval ${2}
    else
        ssh -q -oPasswordAuthentication=no -oStrictHostKeyChecking=no -i ${SECRET_PEM} root@${1} "${2}"
    fi

    local _ret=$?
    if [ $_ret -ne 0 ]; then
        storlog "WARN" "Command failed on ${1}: ${2}"
    fi
    return $_ret
}

scp_do()
{
    # avoid prompting for password, even with password-less scp
    # scp $host1:$file $host2:$file prompts for the password
    scp -q -3 -r -oPasswordAuthentication=no -oStrictHostKeyChecking=no -i ${SECRET_PEM} ${1} ${2}
    local _ret=$?
    if [ $_ret -ne 0 ]; then
        storlog "WARN" "SCP failed from ${1} to ${2}"
    fi
    return ${_ret}
}

# Check that a directory exists, create it otherwise.
# Only use on paths guaranteed to be directories.
ensure_dir()
{
    if [ ! -d "${1}" ] ; then
        mkdir -p "${1}"
    fi
}


# Initializes global variables HA_NUM_SERVERS and HA_SERVERS
determine_servers()
{
    local cmd=${1}
    declare -a servers
    declare -a addrs
	
	# change internal field separator and restore at the end of this function
    local tmp_ifs=${IFS}
    IFS=$'\n'
	
    local num_servers=0
    if [ -s ${CTDB_NODES} ]; then
		# CTDB_NODES should contain the (fixed) IP addresses of the participating nodes, example:
		# 192.168.122.81
		# 192.168.122.82
        eval servers=( $(< ${CTDB_NODES}) )
    fi
    while [ "x${servers[${num_servers}]}x" != "xx" ]; do
        num_servers=$(( ${num_servers} + 1 ))
    done

    HA_NUM_SERVERS=${num_servers}
    HA_SERVERS=( ${servers[*]} )

    if [[ "X${cmd}X" = "XsetupX" ]]; then

        if [ -s ${CTDB_PUBLIC_ADDRESSES} ]; then
			# CTDB_PUBLIC_ADDRESSES should contain the floating IP addresses for the participating nodes
			# We same number of entries in /etc/ctdb/nodes and /etc/ctdb/public_addresses, example:
			# 192.168.122.85 eth0
			# 192.168.122.86 eth0
            eval addrs=( $(< ${CTDB_PUBLIC_ADDRESSES}) )
        fi
        local num_addrs=0
        local index=0
        while [ "x${addrs[${index}]}x" != "xx" ]; do
            index=$(( ${index} + 2 )) 
            num_addrs=$(( ${num_addrs} + 1 ))
        done

        if [[ "${num_servers}" != "${num_addrs}" ]]; then
            storlog "ERR" "num_servers != num_addrs"
            return 1
        fi

    fi
    IFS=${tmp_ifs}
}

### Setup functions

setup_move_ganesha_config()
{
    # we don't do this in the nfs-ganesha-callout. That
    # would do it on every host, we only want to do it
    # once, on a single node

    local mnt=$(mktemp -d /run/gluster/storhaug.XXXXXXXX)

    mount -t glusterfs ${HA_SERVERS[0]}:gluster_shared_storage ${mnt}
	
	# create /nfs-ganesha/exports directory on gluster_shared_storage volume
	# if not created
    ensure_dir ${mnt}/nfs-ganesha/exports
	
	# copy local /etc/ganesha/ganesha.conf to /nfs-ganesha/ on gluster_shared_storage
    cp /etc/ganesha/ganesha.conf ${mnt}/nfs-ganesha/
    eval exports=( $(ls -1 /etc/ganesha/exports) )
    if [[ ! -z ${exports[0]} ]]; then
        cp /etc/ganesha/exports/* ${mnt}/nfs-ganesha/exports/
    fi
    mv /etc/ganesha/ganesha.conf /etc/ganesha/ganesha.conf.orig
    umount ${mnt}
    rmdir ${mnt}

    for srv in ${HA_SERVERS[*]}; do
		# FIXME: this assumes that /etc/ganesha/ganesha.conf should not be present on any of the nodes
        ssh_do ${srv} "ln -s /run/gluster/shared_storage/nfs-ganesha/ganesha.conf /etc/ganesha/ganesha.conf"
    done
}

setup_copy_ctdb_config()
{
    for srv in ${HA_SERVERS[*]}; do
		# FIXME: MY_IPS output is not guaranteed to be ordered, we cannot rely on 0th index
        if [[ ${srv} != ${MY_IPS[0]} ]]; then
            scp_do /etc/ctdb/ctdbd.conf "${srv}:/etc/ctdb/"
            scp_do /etc/ctdb/nodes "${srv}:/etc/ctdb/"
            scp_do /etc/ctdb/public_addresses "${srv}:/etc/ctdb/"
        fi
    done
}

setup_start_ctdb()
{
    for srv in ${HA_SERVERS[*]}; do
        ssh_do ${srv} "systemctl start ctdb"
    done
}

### Teardown functions

teardown_stop_ctdb()
{
    for srv in ${HA_SERVERS[*]}; do
        ssh_do ${srv} "systemctl stop ctdb"
    done
}

teardown_restore_ganesha_config()
{
    ensure_dir /etc/ganesha/exports
    for srv in ${HA_SERVERS[*]}; do
        ssh_do ${srv} "rm /etc/ganesha/ganesha.conf"
    done
    cp /run/gluster/shared_storage/nfs-ganesha/ganesha.conf /etc/ganesha/
    eval exports=( $(ls -1 /run/gluster/shared_storage/nfs-ganesha/exports) )
    if [[ ! -z ${exports[0]} ]]; then
		# FIXME: we don't move this in setup_move_ganesha_config so we should not restore it
        cp /run/gluster/shared_storage/nfs-ganesha/exports/* /etc/ganesha/exports/
    fi 
}

### take_ip, release_ip functions

take_ip()
{
    local fixed_ip=""

    if [ -L /run/gluster/shared_storage/nfs-ganesha/.noderefs/${1} ]; then
        t=$(readlink /run/gluster/shared_storage/nfs-ganesha/.noderefs/${1})
        fixed_ip=$(basename ${t})

        for srv in ${HA_SERVERS[*]}; do
	    # 5 is EVENT_TAKE_IP it starts grace period, clear blocked locks,
	    # release all locks, and update clients using IP address
            ssh_do ${srv} "dbus-send --print-reply --system --dest=org.ganesha.nfsd \
                          /org/ganesha/nfsd/admin org.ganesha.nfsd.admin.grace \
                          string:5:${fixed_ip}"
        done
    fi
}

release_ip()
{
    local fixed_ip=""

    if [ -L /run/gluster/shared_storage/nfs-ganesha/.noderefs/${1} ]; then
        t=$(readlink /run/gluster/shared_storage/nfs-ganesha/.noderefs/${1})
        fixed_ip=$(basename ${t})

        for srv in ${HA_SERVERS[*]}; do
	    # 2 is EVENT_RELEASE_IP it starts grace period, clear blocked locks,
	    # and release all locks 
            ssh_do ${srv} "dbus-send --print-reply --system --dest=org.ganesha.nfsd \
                          /org/ganesha/nfsd/admin org.ganesha.nfsd.admin.grace \
                          string:2:${fixed_ip}"
        done
    fi
}

### export_vol

export_vol()
{
    local exp_id="0"
    local vol_started=""

    vol_started=$(gluster volume status ${1})

	# FIXME: Check if there is a more reliable way to find volume status 
	# checking against a fixed string in the output of a command is poor
    if [ "${started}" = "Volume test is not started" ]; then
        echo "${1} is not started"
        return
    fi

    # FIXME: check that vol isn't already exported

    cat << EOF > /run/gluster/shared_storage/nfs-ganesha/exports/export.${1}.conf
EXPORT {
  Export_Id = __EXPORT_ID__;
  Path = "/${1}";
  Pseudo = "/${1}";
  Access_Type = RW;
  Squash = No_root_squash;
  Disable_ACL = true;
  Protocols = "3","4";
  Transports = "UDP","TCP";
  SecType = "sys";
  FSAL {
    Name = "GLUSTER";
    Hostname = localhost;
    Volume = "${1}";
  }
}
EOF

    exp_id=$(ls -1 /run/gluster/shared_storage/nfs-ganesha/exports/export.*.conf | wc -l)

    sed -i -e s/__EXPORT_ID__/${exp_id}/ /run/gluster/shared_storage/nfs-ganesha/exports/export.${1}.conf

    echo "%include \"/run/gluster/shared_storage/nfs-ganesha/exports/export.${1}.conf\"" >> \
        /run/gluster/shared_storage/nfs-ganesha/ganesha.conf

    for srv in ${HA_SERVERS[*]}; do
        ssh_do ${srv} "dbus-send --print-reply --system --dest=org.ganesha.nfsd /org/ganesha/nfsd/ExportMgr org.ganesha.nfsd.exportmgr.AddExport string:/run/gluster/shared_storage/nfs-ganesha/exports/export.${1}.conf string:EXPORT\(Path=/${1}\)"
    done
}

### Script execution begins here

cmd=${1}; shift
# No argument will get you the help
if [[ ${cmd} == *help || ${cmd} == "-h" || -z ${cmd} ]]; then
    usage
    exit 0
elif [[ ${cmd} == *status ]]; then
    echo "status not implemented yet"
    exit 0
fi

case "${cmd}" in
    setup | --setup)
        storlog "INFO" "Setting up"

        if [[ -e /run/ctdb/ctdbd.pid && -e /proc/$(cat /run/ctdb/ctdbd.pid) ]]; then
            storlog "INFO" "ctdb is already running"
        else
            determine_servers "setup"
            if [ ${HA_NUM_SERVERS} -gt 1 ]; then
                setup_move_ganesha_config
                setup_copy_ctdb_config
                setup_start_ctdb
            else
                storlog "ERR" "Insufficient servers for HA, aborting"
            fi
        fi
        ;;
    teardown | --teardown)
        storlog "INFO" "Tearing down"

        determine_servers "teardown"
        teardown_stop_ctdb
        teardown_restore_ganesha_config
        ;;
    takeip | --takeip)
        storlog "INFO" "takeip"

        determine_servers "takeip"
        take_ip ${1}
	;;
    releaseip | --releaseip)
        storlog "INFO" "releaseip"

        determine_servers "releaseip"
        release_ip ${1}
	;;
    reload | --reload)
	storlog "INFO" "Not implemented: ${cmd}"
        ;;
    export | --export)
        storlog "INFO" "export ${1}"

        determine_servers "export"
        export_vol ${1}      
        ;;
    unexport | --unexport)
	storlog "INFO" "Not implemented: ${cmd}"
        ;;
    add | --add | delete | --delete | remove | --remove)
	storlog "ERR" "Not implemented: ${cmd}"
        ;;
    *)
        storlog "ERR" "Unknown argument: ${cmd}"
        ;;
esac

